$PURPLE$$TX+CX,"Scoping and Linkage"$$FG$
$WW,1$
$LK,"JIT Compile Mode",A="FF:::/Doc/Glossary.TXT,JIT Compile Mode"$ makes use of the current task's hash sym table and its parent tasks' tables.  It fetches syms from parent tasks' tables if not found locally in the current task's table and it places new syms in the current task's table.  Conceptually, syms are at the scope of environment vars in other operating systems.

When a sym is placed into a table, older syms with ident names will be overshadowed if they exist.  Duplicates are not allowed in many cases, especially in asm blks.  Dupicates are allowed, by design in other cases, so that you can repeatedly $GREEN$#include$FG$ the same file from the cmd line while developing it.  Or, so you can repeatedly declare a function with a standard name, like $GREEN$DrawIt()$FG$.  This case might occur when the $GREEN$adam task$FG$ is starting-up loading-in many little utilities.

$GREEN$extern$FG$ binds a new $LK,"HTT_FUN",A="MN:HTT_FUN"$ or $LK,"HTT_GLBL_VAR",A="MN:HTT_GLBL_VAR"$ sym to an existing sym of the same name if it exists in the sym table (just in just-in-time code).  It also can be used to generate a fwd reference.

$GREEN$import$FG$ binds a new $LK,"HTT_FUN",A="MN:HTT_FUN"$ or $LK,"HTT_GLBL_VAR",A="MN:HTT_GLBL_VAR"$ sym to a sym of the same name imported from the task's sym table at $LK,"Load",A="MN:Load"$() time.  If no sym exists to bind to at $LK,"Load",A="MN:Load"$() time, the code using this sym will be left incomplete until the sym is defined.

$WW,1$
$GREEN$_extern$FG$ binds a new $LK,"HTT_FUN",A="MN:HTT_FUN"$ or $LK,"HTT_GLBL_VAR",A="MN:HTT_GLBL_VAR"$ sym to an existing sym, of a $BK,1$different$BK,0$ name.  It must exists in the sym table.  Basically, this binds C to asm.

$GREEN$_import$FG$ binds a new $LK,"HTT_FUN",A="MN:HTT_FUN"$ or $LK,"HTT_GLBL_VAR",A="MN:HTT_GLBL_VAR"$ sym to a sym, of a $BK,1$different$BK,0$ name imported from the task's sym table at $LK,"Load",A="MN:Load"$() time.  If no sym exists to bind to at $LK,"Load",A="MN:Load"$() time, the code using this sym will be left incomplete until the sym is defined.  Basically, this binds C to asm from elsewhere.


$WW,0$$PURPLE$Ahead of Time Compilation$FG$
                    $GREEN$G$FG$lobalScope/$GREEN$F$FG$unctionScope
                    | $GREEN$C$FG$odeHeap/$GREEN$D$FG$ataHeap/$GREEN$S$FG$tack/$GREEN$R$FG$egister
                    | | TaskHashEntry:Export$GREEN$S$FG$ysSym/$GREEN$D$FG$efine/$GREEN$F$FG$unction/$GREEN$C$FG$lass
                    | | | UsageScope: $GREEN$M$FG$odule/$GREEN$A$FG$smLocal/Asm$GREEN$B$FG$lk/$GREEN$T$FG$askAndChildren/$GREEN$F$FG$unction
                    | | | |UsageScope: $GREEN$G$FG$lbl/Asm$GREEN$L$FG$ocal/$GREEN$R$FG$emainder/$GREEN$g$FG$lblThisBlkAndRemainder
                    | | | || $GREEN$S$FG$taticVarInit/$GREEN$D$FG$ynamicVarInitAllowed/$GREEN$N$FG$oInitAllowed
                    | | | || | Are dups allowed within the namespace? A dup overshadows the original.
                    | | | || | $GREEN$D$FG$upsAllowed/$GREEN$N$FG$oDups/NoDupsBut$GREEN$P$FG$ad/$GREEN$W$FG$arningUnlessClosedOut

asm export $GREEN$label::$FG$  G C S MG   N
asm        $GREEN$label:$FG$   G C   MG   N
asm local  $GREEN$@@label:$FG$ G C   AL   N
asm $GREEN$IMPORT label;$FG$   G C   MR   N
asm export $GREEN$label::$FG$  F C S BG   N
asm        $GREEN$label:$FG$   F C   BG   N
asm local  $GREEN$@@label:$FG$ F C   AL   N
asm $GREEN$IMPORT label;$FG$   F C   BR   N
C   goto   $GREEN$label:$FG$   F C   FG   N

           $GREEN$#define$FG$  x     MR   D
           function G C S MR   D
           var      F R   FR   N
           var      F S   FR   N
$GREEN$static$FG$     var      F C   FR D N
           var      G C S MR D D
           var      G D   MR N D
           $GREEN$class$FG$    G     MR   D
class      member   G     MR   P
$GREEN$extern     class$FG$    G     MR   D
$GREEN$extern$FG$     function G C   MR   W
$GREEN$import$FG$     function G C   MR   D
$GREEN$import$FG$     var      G C   MR   D
$GREEN$_extern$FG$    function G C   MR   D
$GREEN$_extern$FG$    var      G C   MR   D
$GREEN$_import$FG$    function G C   MR   D
$GREEN$_import$FG$    var      G C   MR   D


$PURPLE$Just in Time Compilation$FG$
                    $GREEN$G$FG$lobalScope/$GREEN$F$FG$unctionScope
                    | $GREEN$C$FG$odeHeap/$GREEN$D$FG$ataHeap/$GREEN$S$FG$tack/$GREEN$R$FG$egister
                    | | TaskHashEntry:Export$GREEN$S$FG$ysSym/$GREEN$D$FG$efine/$GREEN$F$FG$unction/$GREEN$C$FG$lass
                    | | | UsageScope: $GREEN$M$FG$odule/$GREEN$A$FG$smLocal/Asm$GREEN$B$FG$lk/$GREEN$T$FG$askAndChildren/$GREEN$F$FG$unction
                    | | | |UsageScope: $GREEN$G$FG$lbl/Asm$GREEN$L$FG$ocal/$GREEN$R$FG$emainder/$GREEN$g$FG$lblThisBlkAndRemainder
                    | | | || $GREEN$S$FG$taticVarInit/$GREEN$D$FG$ynamicVarInitAllowed/$GREEN$N$FG$oInitAllowed
                    | | | || | Are dups allowed within the namespace? A dup overshadows the original.
                    | | | || | $GREEN$D$FG$upsAllowed/$GREEN$N$FG$oDups/NoDupsBut$GREEN$P$FG$ad/$GREEN$W$FG$arningUnlessClosedOut

asm export $GREEN$label::$FG$  G C S Tg   N
asm        $GREEN$label:$FG$   G C   BG   N
asm local  $GREEN$@@label:$FG$ G C   AL   N
asm $GREEN$IMPORT label;$FG$   G C   TR   N
asm export $GREEN$label::$FG$  F C   BG   N
asm        $GREEN$label:$FG$   F C   BG   N
asm local  $GREEN$@@label:$FG$ F C   AL   N
asm $GREEN$IMPORT label;$FG$   F C   BR   N
C   goto   $GREEN$label:$FG$   F C   FG   N

           $GREEN$#define$FG$  x   D TR   D
           function G C F TR   D
           var      F R   FR   N
           var      F S   FR   N
$GREEN$static$FG$     var      F C   FR D N
           var      G C G TR D D
           var      G D G TR S D
           $GREEN$class$FG$    G   C TR   D
class      member   G     TR   P
$GREEN$extern     class$FG$    G   C TR   D
$GREEN$extern$FG$     function G C F TR   W
$GREEN$extern$FG$     var      G C G TR   D
$GREEN$extern$FG$     var      G D G TR   D
$GREEN$_extern$FG$    function G C F TR   D
$GREEN$_extern$FG$    var      G C G TR   D

$WW,1$
* Goto labels must not have the same name as global scope objects.  GoTo's are rare and I don't want to slow the compiler and add code to fix this.  You will get errors if a collision happens, so it's not very dangerous, but the error message is baffling.

* The member names $GREEN$pad$FG$ and $GREEN$reserved$FG$ are special because multiple instances with the same name are allowed in a class.

* Use $GREEN$reg$FG$ or $GREEN$noreg$FG$ in front of local var names to override automatic reg var allocation.  You can, optionally, specify a reg after the $GREEN$reg$FG$ keyword.
 
* Local non-reg function vars can be accessed in asm blks with $GREEN$&i[RBP]$FG$ for example.

* Glbl vars and functions can be accessed in asm with and $GREEN$&$FG$ as in
	$GREEN$MOV	RAX,I64 [&glbl_var]
	CALL	I32 &Fun
	CALL	I32 &SYS_SYM$FG$

* In $GREEN$JIT$FG$ asm code, &SYS_SYM and &Fun don't need $GREEN$IMPORT$FG$.

* All offspring tasks of a task inherit syms.

* The $GREEN$sizeof()$FG$ and HolyC structure members can be used in asm blks.

* Using $GREEN$&i$FG$ in $LK,"HolyC",A="FI:::/Doc/HolyC.TXT"$ or $GREEN$i.u8[2]$FG$ on a local var, $GREEN$i$FG$, will force it to $GREEN$noreg$FG$.

* Using $GREEN$try$FG$/$GREEN$catch$FG$ in a function will force all local vars to $GREEN$noreg$FG$.

* An unused gap on the stk is left for $GREEN$reg$FG$ vars.

* Note: $GREEN$static$FG$ function vars do not go on the data heap, no matter the setting of the $LK,"OPTf_GLBLS_ON_DATA_HEAP",A="MN:OPTf_GLBLS_ON_DATA_HEAP"$$FG$.  They may in the future.

* $LK,"OPTf_EXTERNS_TO_IMPORTS",A="MN:OPTf_EXTERNS_TO_IMPORTS"$ will treat $GREEN$_extern$FG$ as $GREEN$_import$FG$ and $GREEN$extern$FG$ as $GREEN$import$FG$.  This allows a header to be used either as a $GREEN$JIT compiled$FG$ or $GREEN$AOT compiled$FG$ header.
