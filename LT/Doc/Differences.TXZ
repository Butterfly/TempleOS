$WW,1$$FG,5$$TX+CX,"Departures from C/C++:"$$FG$

* Built-in types include $FG,2$I0,I1,I2,I4,I8$FG$ for signed ints and $FG,2$U0,U1,U2,U4,U8$FG$ for unsigned ints and $FG,2$double$FG$.

* The "$FG,2$`$FG$" operator raises a base to a power.

* Operator Precidence
  1) $FG,2$`$FG$,$FG,2$>>$FG$,$FG,2$<<$FG$
  2) $FG,2$*$FG$,$FG,2$/$FG$,$FG,2$%$FG$
  3) $FG,2$&$FG$
  4) $FG,2$|$FG$,$FG,2$^$FG$
  5) $FG,2$+$FG$,$FG,2$-$FG$
  6) $FG,2$==$FG$,$FG,2$!=$FG$,$FG,2$<$FG$,$FG,2$>$FG$,$FG,2$<=$FG$,$FG,2$>=$FG$
  7) $FG,2$&&$FG$
  8) $FG,2$||$FG$,$FG,2$^^$FG$
  9) $FG,2$:$FG$,$FG,2$?$FG$
  10) $FG,2$=$FG$,$FG,2$<<=$FG$,$FG,2$>>=$FG$,$FG,2$*=$FG$,$FG,2$/=$FG$,$FG,2$&=$FG$,$FG,2$|=$FG$,$FG,2$^=$FG$,$FG,2$+=$FG$,$FG,2$-=$FG$

* Allows "$FG,2$5<i<j<20$FG$" instead of "$FG,2$5<i && i<j && j<20$FG$".

* With the $FG,2$#exe{}$FG$ feature in your source code, you can place programs that insert text into the stream of code being compiled.  See $LK,"#exe {}","FF:::/LT/OSMain/OSEnd.CPZ,#exe {"$ for an example where the date/time and compile-time prompting for configuration data is placed into a program.  The $LK,"ExePrintF","MN:ExePrintF"$() and $LK,"ExePutS","MN:ExePutS"$() place text into a source program stream following the conclusion of the $FG,2$#exe{}$FG$ blk.

* No "$FG,2$#define$FG$" functions exist (I'm not a fan)

* Pointer arithmetic is not based on size of objects (I'd have no objections to this changing)

* No type-checking

* Variable parameter cnts ($FG,2$...$FG$) are accessed with "$FG,2$argc$FG$" and "$FG,2$argv[]$FG$" which are predefined invisible local variable.

* "$FG,2$cout$FG$" works with commas but not "$FG,2$<<$FG$" and has no "$FG,2$endl$FG$" or other codes.  Use "$FG,2$coutln$FG$" to print a carriage return after other stuff.  An alias for "$FG,2$cout$FG$" is "$FG,2$dbgo$FG$" or "$FG,2$dbgoln$FG$" and is useful for debugging--I often place debug output all over the place and do a $LK,"Grep","MN:Grep"$() to locate them all.

* Type casting is done with "$FG,2$><(classname)$FG$" and is postfix.

* When dealing with function addresses, precede the name with "$FG,2$&$FG$".  With this syntax change, a function name by itself can be used as a call like a Pascal procedure with no "()" if there are no parameters or there are just default parameters.

* "$FG,2$$$$FG$" is an escape character.  Two dollar signs signify an ordinary $$.  See $LK,"::/LT/Doc/Dollar.TXZ","FI:::/LT/Doc/Dollar.TXZ"$.

* There is not a "$FG,2$struct$FG$" keyword, just "$FG,2$class$FG$".

* "$FG,2$union$FG$" is more like a class, so you don't referrence it with a "$FG,2$union$FG$" label after you define it.  Some common unions are declared in $LK,"AdamK.HPZ","MN:U2"$ for 1,2,4 and 8 byte objects.  If you place a type in front of a union declaration, that is the type when used by itself.

* You cannot declare instances of "$FG,2$class$FG$es" or "$FG,2$unions$FG$" in the same statement where they are defined.

* $FG,2$class$FG$ member vars have two keywords for associating data with member vars -- "$FG,2$fmtstr$FG$" and "$FG,2$fmtdata$FG$".  All compiler structures are saved and you can access the compiler's info about classes and variables.  In the future, I hope to have arbitrary named data items on class definitions.

* "$FG,2$static$FG$" variables in functions are not allowed and I have no plans for doing them--just use a global variable.

* See $LK,"::/LT/Demo/Exceptions.CPZ","FI:::/LT/Demo/Exceptions.CPZ"$.  "$FG,2$try{} catch{}$FG$ and $FG,2$throw$FG$" are different from C++. "$FG,2$throw$FG$" is a function with variable ("$FG,2$...$FG$") parameters.  The values passed in "$FG,2$throw()$FG$" can be accessed from within a "$FG,2$catch{}$FG$" using the "$FG,2$Fs->except_argc$FG$" and "$FG,2$Fs->except_argv[]$FG$" variables.  Within a "$FG,2$catch {}$FG$" blk, set the var "$FG,2$Fs->catch_except$FG$" to "$FG,2$TRUE$FG$" if you want to terminate the search for a handler.  By convention, the first parameter of $FG,2$except_argv[]$FG$ specifies the exception type number.  A list of assigned exception types can be found at $LK,"EXCEPT_LOCAL","MN:EXCEPT_LOCAL"$.  For a handler that will catch all excepts, you can use $LK,"CatchAll","MN:CatchAll"$().

* A function is available similar to "$FG,2$sizeof$FG$" which provides the offset of a member of a class.  It's called "$FG,2$offset()$FG$".  You place the class name and member inside as in "$FG,2$offset(classname.membername)$FG$".  It has nothing to do with 16-bit code.  Both $FG,2$sizeof()$FG$ and $FG,2$offset()$FG$ only accept one level of member variables.  That is, you cannot do $FG,2$sizeof(classname.membername.submembername)$FG$.$FG$

* There is a function called $LK,"MSize","MN:MSize"$() which gives the size of an object allocated off the heap.  For larger size allocations, the system rounds-up to a power of two, so $FG,2$MSize()$FG$ lets you know the real size.

* You can $LK,"Free","MN:Free"$() a $FG,2$NULL$FG$ pointer.  Useful variants of $LK,"MAlloc","MN:MAlloc"$() can be found $LK,"Here","MN:MAllocZ"$.  Each task has a heap and you can $FG,2$MAlloc$FG$ and $FG,2$Free$FG$ off of other task's heaps.

$FG,5$$TX+CX,"PrintF Family"$$FG$
$AN,"","PrintF_Codes"$
$LK,"MSPrintF","MN:MSPrintF"$() is like $LK,"SPrintF","MN:SPrintF"$() but it returns a $LK+S,"MAlloc","MN:MAlloc"$ated str.  It is vary handy because you don't have to worry about overflow.

$LK,"Auto","MN:Auto"$(I1 *src,...) and text to the current task's input buffer.
$LK,"AutoStr","MN:AutoStr"$(I1 *src,...) sends text of an $LK,"AutoFile","FF:::/LT/Doc/OSGlossary.GLZ,AutoFile"$ to the keyboard stream of the current TASK but can also do mouse commands.

$LK,"XTalk","MN:XTalk"$(TssStruct *tss,I1 *src,...) and text to another task's input buffer.
$LK,"XTalkStr","MN:XTalkStr"$(TssStruct *tss,I1 *src,...) sends text of an $LK,"AutoFile","FF:::/LT/Doc/OSGlossary.GLZ,AutoFile"$ to the keyboard stream of another TASK but can also do mouse commands.


$LK,"LtfPutSExt","MN:LtfPutSExt"$(Ltf *l,I1 *src) and $LK,"LtfPrintF","MN:LtfPrintF"$(Ltf *l,I1 *src,...) send text to a linked text file.  You can buffer to a Ltf and save it, providing the functionality of $FG,2$fprintf$FG$.  See $LK,"::/LT/Demo/FPrintF.CPZ","FI:::/LT/Demo/FPrintF.CPZ"$.

$LK,"Adam","MN:Adam"$(I1 *src,...) send text to the adam task to be compiled and run.
$LK,"AdamLog","MN:AdamLog"$(I1 *src,...) and $LK,"AdamErr","MN:AdamErr"$(I1 *src,...) send text to the adam task to be displayed.


$LK,"Lpt1PrintF","MN:Lpt1PrintF"$(I1 *src,...) send text to the printer port.

$LK,"ExePrintF","MN:ExePrintF"$(I1 *src,...) and $LK,"ExePutS","MN:ExePutS"$(I1 *src) send text to the stream of code being compiled and must reside in a $FG,2$#exe{}$FG$ blk.

$BK,1$Note:$BK,0$ If no $FG,2$PutS$FG$ variant is available, you can use $FG,2$PrintF("%s",src)$FG$.


The $LK,"PrintF","MN:PrintF"$() family supports extended format codes.
  * $FG,2$"%n"$FG$ will print a floating point in scientific notation.
  * $FG,2$"%S"$FG$ will print a systext entry.
  * $FG,2$"%C"$FG$ will print a ToUpper character.
  * $FG,2$"%F"$FG$ will print a text file.
  * $FG,2$"t"$FG$ is a flag which will truncate to field width.
  * $FG,2$"%P"$FG$ will display a PSECT expression which is good for pointers or addresses.
  * $FG,2$"%T"$FG$ and $FG,2$"%D"$FG$ will display a date or time and the format is selected with a subcode, entered after a "$FG,2$h$FG$".  Example: "$FG,2$%20h1D$FG$" uses date format code "1". See $LK,"MSPrintFDate","MN:MSPrintFDate"$() and $LK,"MSPrintFTime","MN:MSPrintFTime"$() for subcodes.
  * $FG,2$"%z"$FG$ will display a sub entry of an enumerated list of text entries. It calls $LK+S,"PointAtListEntry","MN:PointAtListEntry"$().
  * $FG,2$"%Z"$FG$ will display a SysText sub entry.
  * $FG,2$"%Q"$FG$ will convert "\" to "\\" and quote to backslash quote. (For use in creating strs in strs.)
  * $FG,2$"%q"$FG$ will reverse a $FG,2$"%Q"$FG$.
