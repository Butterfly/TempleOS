$WW,1$$FG,5$$IV,1$$TX+CX,"TIPS"$$IV,0$$FG$

* Turn-off or reboot($FG,2$CTRL-ALT-DEL$FG$) at any time, except during disk writes.  Writes are not cached.

* If you make changes to LoseThos files in your account directory, some will be complied at boot time, others when you open a new user window.  So, you don't need to recompile the kernel ($FG,2$OSMain$FG$).  You should have two LoseThos partitions on your hard drive because a syntax error in a start-up file will make the partition unbootable.  Boot to the second partition and fix it, or boot to a CD-ROM and use $LK,"AddDrives","MN:AddDrives"$() to mount your hard drive.

* Press the $FG,2$WINDOW$FG$'s key at the command line to access your macro/menu area.  Place macros there with $FG,2$CTRL-L$FG$, or icon-like pictures with $FG,2$CTRL-R$FG$.  Use the "$FG,2$Pop-Up$FG$" option on macros to $LK,"Spawn","MN:Spawn"$() a task to run a file.  It dies when it is finished.  This returns memory to the system.  Be sure to press $FG,2$CTRL-S$FG$ to save your macro/menu area after making changes.

* You can adjust the number of answers displayed by setting $FG,2$Fs->answers_displayed$FG$ to a number from 0-8 in your $LK,"HOME/User.CPZ","FI:HOME/User.CPZ"$ file.

* You can adjust the mouse movement rate by setting global variables in your start-up file.  See $LK,"mouse_scale","FA:HOME/Adam3.APZ,mouse_move_scale"$.

* You can set your local time zone by setting the $LK,"local_time_offset","MN:local_time_offset"$ global variable in a start-up file.  It's units are $LK,"LTDATE_FREQ","MN:LTDATE_FREQ"$.  See $LK,"local time","FF:HOME/Adam3.APZ,local_time"$.

* You can define or redefine behavior of all keys in your $LK,"MyPutKey","MN:MyPutKey"$() routine.

* You can use "$FG,2$ans0$FG$","$FG,2$ans1$FG$", etc in expressions.  You can use the cmd prompt as a calculator by just entering expressions like "$FG,2$1+2*3;$FG$".  $FG,2$double$FG$ results can be accessed with "$FG,2$ansd0$FG$" or "$FG,2$ansd1$FG$".

* You can recompile and reinstall the kernel with $LK,"InstallBoot","MN:InstallBoot"$().  You'll probably want to make a function for recompiling that uses the $LK,"Auto","MN:Auto"$() function to answer the config questions.

* You can disable $FG,2$WORDSTAT$FG$ commenting-out $LK,"WsInit","FF:HOME/Adam3.APZ,WsInit"$() and the $LK,"Spawn","MN:Spawn"$() in $LK,"HOME/Adam3.APZ","FF:HOME/Adam3.APZ,WsInit"$.

* You can disable MutliCore by commenting-out $LK,"MPStart","FF:HOME/Adam3.APZ,MPStart"$ in $LK,"HOME/Adam3.APZ","FF:HOME/Adam3.APZ,MPStart"$.

* You can use $LK,"progress1","MN:progress1"$-$LK,"progress4","MN:progress4"$ in your programs for whatever you like.  They're just global variables that are shown on the wallpaper.  The original intent was to indicate how far along operations were.  There's no coordination, so different apps might interfere.  I use them most for debugging--just values easily viewed.

* Use $LK,"LtfMax","MN:LtfMax"$() to adjust the size of the cmd line buf.  It counts $LK,"Ltf","MN:Ltf"$ entries, not lines.

* You can get rid of the splash screen by commenting-out the start song in $LK,"HOME/Adam3.APZ","FF:HOME/Adam3.APZ,StartSong"$.

* You can reduce memory usage by making a smaller disk cache when you recompile the kernel; disabling $FG,2$WORDSTAT$FG$; Specifying smaller stack sizes when doing $LK,"Spawn","MN:Spawn"$(), changing $LK,"DEFAULT_STACK","MN:DEFAULT_STACK"$, and using $LK,"LtfMax","MN:LtfMax"$() to reduce the command line buffer size.

* Filenames ending in "$FG,2$Z$FG$" will be automatically compressed and uncompressed when read or written.  The compression method is not supported by other operating systems.  You can store files uncompressed by $LK,"Move","MN:Move"$()ing them to a filename not ending in "$FG,2$Z$FG$".  See $LK,"::/LT/Doc/LTZ.TXZ","FI:::/LT/Doc/LTZ.TXZ"$ if you want to uncompress while in $FG,2$WINDOWS$FG$.

* The joystick can be recalibrated with $LK,"JoyCalibration","MN:JoyCalibration"$().

* $LK,"MergeChk","MN:MergeChk"$() can be used to see what's changed.  The "$FG,2$+d$FG$" flag will show differences of files which have changed and allow you to merge code.  (The "$FG,2$+r$FG$" flag will recurse.)

* There is a utility $LK,"LinkChk","MN:LinkChk"$() which will check for broken links in documentation.

* Use $LK,"Plain","MN:Plain"$() to edit a plain text file.  You'll need this if your file has $FG,2$$$$FG$'s.

* Use $LK,"Silent","MN:Silent"$() to disable screen text output.
* Use $LK,"IOSound","MN:IOSound"$() to disable noise from disk access.

* There are handy functions--$FG,2$F(),R(),FD()$FG$ and $FG,2$RD()$FG$ which are defined in $LK+S,"HOME/User.CPZ","FI:HOME/User.CPZ"$.  You're encouraged to change them, since they're in account files.  They will perform find-and-replace operations accross multiple files.  The "$FG,2$+l$FG$" flag is particularly useful since it limits to whole labels.  You are encouraged to add or modify handy wrapper functions to make command line operations easier.

* You can save files after making changes, anytime you are within the editor, like when viewing help/macro files.  $FG,2$CTRL-A$FG$ saves as, $FG,2$CTRL-S$FG$ saves with the same name in the scrolling title bar.  Hitting $FG,2$ESC$FG$ will exit and save.  ($FG,2$CTRL-Q$FG$ will exit and not save).  You can save the cmd line window to a file, too, since you're actually in the editor when you're at the cmd line.

* When using $FG,2$CTRL-L$FG$ to insert links in documents, you can usually leave the "Display Text" blank and it will be filled-in automatically based on other entries.

* There is a feature of the precompiler that allows code to be executed in the middle of compilation and data inserted into the compilation stream.  Click here for an example: $LK,"#exe {","FF:::/LT/OSMain/OSEnd.CPZ,#exe {"$.

* If you output to the cmd line and wish to allow users to scroll around and view data, you can use $LK,"View","MN:View"$().  $LK,"Example","MN:WsPutMatrix"$

* Use $LK+S,"View","MN:View"$() in Pop-up macros to linger until the user presses $FG,2$ESC$FG$ or $FG,2$CTRL-Q$FG$.

* You can access the word under the cursor at $LK,"ws_cur_word","MN:ws_cur_word"$, but you should probably turn-off preemption or interrupts momentarily to copy it.

* You can reactivate $FG,2$WORDSTAT$FG$ after closing it by pressing $FG,2$CTRL-FUNCTION KEY$FG$.

* $LK,"Preempt","MN:Preempt"$() is used to keep a task from being interrupted and swapped-out.  It has a similar effect to turning-off interrupts.  Each task has it's own preemption control.  A task with preemption turned-off can voluntarily $LK,"SwapInNext","MN:SwapInNext"$() with preemption off.

* You can set a color for different drives with $LK,"SetDriveTextAttr","MN:SetDriveTextAttr"$().  Place calls to this in $LK,"::HOME/User.CPZ","FI:::HOME/User.CPZ"$.

* If you toggle to plain text when you are working with graphics in a document, you can add duplicate entries for pictures by entering a "$FG,2$PI$FG$" command with the same number.

* If you toggle to plain text when working with graphics, you can add a str to the $FG,2$$$PI$$$FG$ entry to keep track of it.  Try "$FG,2$$$PI,"<2>",2$$$FG$" where '2' is the picture number.

* I use spaces-to-tab operations on all my files to keep them small.  You have to be careful, though, because spaces in strings will be converted.  I use $FG,2$SHIFT-SPACE$FG$ ' ' in such cases.  See $LK,"S2T","MN:S2T"$() for spaces-to-tabs.

* You can edit an existing Graphic Element by putting the cursor on it and pressing $FG,2$CTRL-R$FG$.

* You might want to stick with manually filling-in a GrElem by drawing lines instead of flood-fill or convert the GrElem to bitmaps.  Bitmaps are a little slow and flood-fill behaves weird based on what's underneath.  Artistically, you get good results with brush-strokes produced by drawing with lines.

* You can customize the "wallpaper".  See $LK,"::/LT/Demo/Graphics/MyWallPaper.APZ","FI:::/LT/Demo/Graphics/MyWallPaper.APZ"$.

* You can adjust the screen refresh rate (software).  It is automatically adjusted based on load.  The range is $LK,"win_min_refresh","MN:win_min_refresh"$,$LK,"win_max_refresh","MN:win_max_refresh"$.


$FG,5$$IV,1$$TX+CX,"DEBUGGING"$$FG$$IV,0$

* While debugging, you specify addresses of assembly OSmain $FG,2$asm{}$FG$ routines with just the label, as in "$FG,2$CP_MALLOC+0x20$FG$".  You specify $FG,2$C+$FG$ labels with "$FG,2$&$FG$" before functions as in "$FG,2$&Printf+0x10$FG$".

$LK,"D","MN:D"$() $LK,"LtfD","MN:LtfD"$() to hex dump mem with numbering from zero.  With $LK,"LtfD","MN:LtfD"$ the values are updated continually and you can alter mem by editing.

$LK,"Dm","MN:Dm"$() $LK,"LtfDm","MN:LtfDm"$() to hex dump mem with addresses showing.

$LK,"Dasm","MN:Dasm"$() to disassemble mem.

$LK,"ProfBin","MN:ProfBin"$(),$LK,"ProfAll","MN:ProfAll"$() and $LK,"ProfRep","MN:ProfRep"$() provide code profiling.  See $LK,"::/LT/Demo/AutoFile/Demo2.AUZ","FI:::/LT/Demo/AutoFile/Demo2.AUZ"$ (This is an "$LK,"AutoFile","FF:::/LT/Doc/OSGlossary.GLZ,AutoFile"$".)

* Use $LK,"DbgNum","MN:DbgNum"$(), $LK,"DbgStr","MN:DbgStr"$() and $LK,"DbgAdd","MN:DbgAdd"$() to print debug info bypassing the window framework.  You can use $LK,"Raw","MN:Raw"$($FG,2$TRUE$FG$) to make all output bypass the window framework.

* Use $LK,"SysDbg","MN:SysDbg"$() to set a flag which you can read with $LK,"IsSysDbg","MN:IsSysDbg"$() when you wish to trigger some debug activity.

* There are flags for various trace options that can help debugging when there are compiler bugs.
$ID,2$
$LK,"Echo","MN:Echo"$() turns on or off raw data going into the lexical analyzer.

$LK,"LTrace","MN:LTrace"$() shows the tokens coming out of the lexical analyzer.

$LK,"CTrace","MN:CTrace"$() disassembles code generated from the C+ compiler.

$LK,"PTrace","MN:PTrace"$() shows "intermediate code" comming out of the first stage of the compiler (it's not 100% valid because it hasn't been fixed-up).

$LK,"OTrace","MN:OTrace"$() shows intermediate code coming-out after optimization.  $LK,"OPassTraceMask","MN:OPassTraceMask"$() controls which passes are displayed.

These flags can be set and reset by placing them in "$FG,2$#exe{}$FG$" code blks.
$ID,-2$

* $FG,4$dbgo$FG$ is an alias for "$FG,2$cout$FG$" and can be used to place output.  You can easily find and remove them doing a $LK,"Grep","MN:Grep"$().

* $LK,"SBpt","MN:SBpt"$() to set breakpoints.  When the fault screen appears, use $LK,"Go","MN:Go"$() to continue.  You can altering modify what is displayed each break-point by $LK,"HOME/Fault.CPZ","FI:HOME/Fault.CPZ"$ in your account's home directory.

* There is a heap check utility which can find leaks.  Use $LK,"HeapLog","MN:HeapLog"$(), and $LK,"HeapLogRep","MN:HeapLogRep"$().  It's a really simple program which intercepts $LK,"MAlloc","MN:MAlloc"$() and $LK,"Free","MN:Free"$().  You can customize the code to find other heap issues.

* You can define functions for $FG,2$CTRL-ALT-LETTER$FG$ keys, but they must operate in a interrupt environment.  You can do $LK,"Raw","MN:Raw"$() output.  Scan for $LK,"ctrl_alt_letter_routines","MN:ctrl_alt_letter_routines"$[] and look at the code.
 