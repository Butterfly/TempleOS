$WW,1$$TR,"Task"$
$ID,2$A "task" is the Intel term for a "process".  Each task has a $LK+S,"TssStruct","MN:TssStruct"$, the name derived from "Task State Something".  The "$FG,2$Fs$FG$" segment register is maintained pointing to the current TssStruct.  There is only one window per task.
$ID,-2$$TR,"Adam Task"$
$ID,2$This is Adam, as in Adam and Eve, the parent of all tasks.  This task is created at start-up and appears in the small window at the top beneath the user windows.  On it's heap are all mem objects which are system wide.  When created, it runs the file $LK,"::/LT/OSMain/AdamK.APZ","FI:::/LT/OSMain/AdamK.APZ"$$ER$  Normally, AdamK.APZ ends by $FG,2$#include$FG$ $LK,"::/LT/Adam/Adam2.APZ","FI:::/LT/Adam/Adam2.APZ"$ where the remainder of the operating system is "$FG,2$#include$FG$d".  When start-up is finished, the adam task enters a server mode where it accepts requests from other tasks.  The $LK,"Adam","MN:Adam"$("") routine will cause the adam task to compile and run text source code.  "$FG,2$#include$FG$" statements can be sent to the $LK,"Adam","MN:Adam"$("") routine, creating system-wide code and data which don't disappear when any particular task ends.  (The Adam task is immortal.)
$ID,-2$$TR,"Cain Task"$
$ID,2$This is Cain, as in Adam and Eve's child.  Each CPU has a special task which is immortal and which is special.  The Adam task on CPU#0 is also it's Cain task.
$ID,-2$$TR,"Parent/Child Task"$
$ID,2$Often a task will $LK,"Spawn","MN:Spawn"$() or $LK,"PopUp","MN:PopUp"$() a task as a helper.  The helper is known as a Child Task, though you can $FG,2$Spawn$FG$ a task and assign it a different parent... like Adam.  Links are kept as to who Spawned what so that when one task is $LK,"Kill","MN:Kill"$()ed the helper tasks disappear, too.  You see a report on current system tasks with $LK+S,"TaskRep","MN:TaskRep"$().  There is just one possible window per task, so child tasks are needed.
$ID,-2$$TR,"C+"$
$ID,2$The language used by LoseThos is more than "$FG,2$C$FG$" and less than "$FG,2$C++$FG$", so it's just "$FG,2$C+$FG$".  It has the default parameter feature of $FG,2$C++$FG$ and uses $FG,2$class$FG$ in place of $FG,2$struct$FG$.  It uses $FG,2$U1,U2,U4,U8$FG$ and $FG,2$I1,I2,I4,I8$FG$ for signed and unsigned integers.  It has a slightly different operator precidence.  See $LK,"OP_Precidence","FA:::/LT/Compiler/CmpInit.CPZ,OP_Precidence"$  It has the $FG,2$PASCAL$FG$ like feature of function calls with no parens, but requires an "$FG,2$&$FG,2$$FG$" when referring to a function address.
$ID,-2$$TR,"Static Compiled Mode"$
$ID,2$I coined this term to refer to conventional compilation mode, but it is not the preferred mode for this operating system and is discouraged.  "$FG,2$.BI?$FG$" files are created directly, skipping "$FG,2$.OBJ$FG$" files.  In this mode, code and data are contiguous.  After compiling, you do a $LK,"Load","MN:Load"$() cmd which is available from right-clicking on a link (like from $LK,"Dir","MN:Dir"$()).  There is no "$FG,2$main()$FG$" routine.  Instead, statements outside functions are automatically executed upon loading.  There is no way to unload except by killing the task.  To invoke $FG,2$Static Compiled Mode$FG$, use the $LK,"CompileFile","MN:CompileFile"$() routine or right-click on a link.  The OSmain and compiler are made in static compiled mode and stored in "$FG,2$Boot.BIC$FG$" and "$FG,2$Compiler.BIZ$FG$".
$ID,-2$$TR,"Dynamic Compiled Mode"$
$ID,2$I coined this term to refer to the mode when the compiler allocates objects(code and data) from the heap, noncontiguously.  This mode is used during command-line operations.  When you "$FG,2$#include$FG$" a file, it is compiled function by function and objects are placed all over in mem.  The $LK,"ExecuteFile","MN:ExecuteFile"$() routine is the same as "$FG,2$#include$FG$" but can be placed in programs.  $LK,"ExecuteStr","MN:ExecuteStr"$() routine will compile and run a str.  "$FG,2$asm{}$FG$" cmds are not allowed in Dynamic mode.
$ID,-2$$TR,"Compiler Intermediate Code"$
$ID,2$The compiler generates instructions one step before making actual assembly(machine) language instructions.  This code is reverse polish in nature and can be viewed with $LK,"PTrace","MN:PTrace"$() or $LK,"OTrace","MN:OTrace"$().  The compiler does not "interpret" code, except in the process of optimization.  The assembly language can be viewed when it is compiled with the $LK,"CTrace","MN:CTrace"$() routine, or afterward with $LK,"Dasm","MN:Dasm"$().
$ID,-2$$TR,"File Partition"$
$ID,2$There are physical partitions on disks and then there are virtual partitions which are stored in files on other partitions.  This is a LoseThos feature.  You can create a file partition using AddDrives or at the prompt when you recompile the operating system.  Enter the filename including the drive letter.  If you answer "Yes" to the prompt on reformating, this partition will be reformatted each time you use it for the first time after booting.  The original purpose of file partitions was as a holding area to collect files to write to a CD-ROM.  Use the file partition's letter when calling $LK,"CreateCDFile","MN:CreateCDFile"$().
$ID,-2$$TR,"Hard-coded"$
$ID,2$When you use a raw number instead of a $FG,2$#define$FG$'ed label, that's called "hard-coding".  Use labels whenever possible or your programs will fail if numbers change when the operating system is updated.
$ID,-2$
$LK,"AutoFile","HI:AutoFile"$
$LK,"Graphic Element","HI:Graphics/GrElem"$
$LK,"Hash Table","HI:Hash"$
$LK,"PicWords","HI:PicWords"$
$LK,"SysText","HI:Char/SysText"$


$FG,5$$TX+CX,"FileNames"$$FG$

$FG,5$Wildcards$FG$
  FileName wild card matching allows "$FG,2$*$FG$" to match sequences of arbitrary characters and "$FG,2$?$FG$" for a single arbitrary character.  For some commands, you can enter multiple specifiers separated by "$FG,2$;$FG$".  You don't need to, but can, use "$FG,2$*.*$FG$" instead of "$FG,2$*$FG$" for filenames.  You can specify names to exclude by using a "$FG,2$~$FG$".

$FG,5$*.??Z$FG$
  These files are automatically compressed or uncompresses files when read or written.
$FG,5$$FG,5$*.??C$FG$
  Contiguous files--NOT compressed.
$FG,5$*.TX?$FG$
  Text Files
$FG,5$*.GL?$FG$
  Glossary Files--WordStat will show a "$FG,2$#$FG$" next to words which are defined as anchors within glossary files.
$FG,5$*.CP?$FG$
  C+ source files.  The default C+ compiler type is "$FG,2$.CPZ$FG$".
$FG,5$*.SP?$FG$
  C+ source files to be compiled statically.
$FG,5$*.AP?$FG$
  C+ source files meant to be included into the Adam Task.
$FG,5$*.HP?$FG$
  C+ source header files.
$FG,5$*.AS?$FG$
  Assembly source files.  The default assembler type is "$FG,2$.ASZ$FG$".
$FG,5$*.MU?$FG$
  Menu/Help/Macro files
$FG,5$*.MP?$FG$
  Compiler "map" files
$FG,5$*.BI?$FG$
  Binary executable files, created by $LK,"CompileFile","MN:CompileFile"$() and read by $LK,"Load","MN:Load"$().
$FG,5$*.DT?$FG$
  Data files
$FG,5$*.DVC$FG$
  File Partition Drive (A drive stored in a file on another partition)
$FG,5$$FG,5$*.IS?$FG$
  CD-ROM image file--ISO9660.  To burn on other operating systems, rename "$FG,2$.ISO$FG$"
$FG,5$*.AUZ$FG$
  "AutoFile" Basically a C+ program who's stdout goes to the input of a task when $LK,"AutoFile","MN:AutoFile"$() is called.

$LK,"SOURCE_FILE_MASK","MN:SOURCE_FILE_MASK"$$FG$
  This $FG,2$#define$FG$ holds a list of source file extensions.
$LK,"TEXT_FILE_MASK","MN:TEXT_FILE_MASK"$$FG$
  This $FG,2$#define$FG$ holds a list of text file extensions.



$FG,5$$TX+CX,"Naming conventions"$
$FG$
$FG,5$$FG$The following are rules I stick to.  If you work on the operating system, it'd be good to stick with them for uniformity, but you can do what you like.  Since there are no "$FG,2$namespaces$FG$" and I don't plan to implement name spaces, I highly recommend putting a 2-3 character module code prefix on symbols. e.g. "Ws","Ltf","Lex"

$FG,5$ALL_CAPS$FG$
  Assembly Language labels are capitalized with underscores between words.  So are $FG,2$#define$FG$'s.

$FG,5$MixedCaps$FG$
  $FG,2$C+$FG$ Functions and class names are MixedCaps.

$FG,5$lower_case$FG$
  Local function vars and glbl vars are lower case.  Class member names are also lower_case.

$FG,5$SYSf_????$FG$
  Flags which are designated with bit numbers instead of bit values are designated with a lower case "$FG,2$f$FG$".

$FG,5$CP_????$FG$
  Assembly language routines which are C+ callable have a prefix "CP_".



$AN,"Fs","Fs"$
  This refers to the CPU segment register called FS.  This register is special in LoseThos because it points to the currently active task's $LK,"TssStruct","MN:TssStruct"$.


$AN,"Gs","Gs"$
  This refers to the CPU segment register called GS.  This register is special in LoseThos because it points to the currently active task's $LK,"CPUStruct","MN:CPUStruct"$.

$AN,"Tss","Tss"$
  This is an Intel abbreviation for task state something.  Each task has one of these structures.
 
$AN,"Bt,Bts,Btr,Btc","Bt,Bts,Btr,Btc"$
  These are bit manipulation functions named after Intel instructions.  They stand for "Bit Test", "Bit Test and Set", "Bit Test and Reset" and "Bit Test and Compliment".

$AN,"Cli,Sti","Cli,Sti"$
  These functions turn on or off interrupts.  They are named after the Intel instructions.  "Cli" turns off interrupts.

$AN,"Heap","Heap"$
  Programs can dynamically request chunks of memory allocated from a "heap" using $LK,"MAlloc","MN:MAlloc"$().  They must be sure to $LK,"Free","MN:Free"$() it when finished.  Pointers are used to refer to it.  The "heap" is dynamically allocated memory.

$AN,"Root","root"$
  Refers to the base of a binary tree or the head of a queue.

$AN,"Join","Join"$
  When two parts of a program have a common low-level routine, that routine is often labeled SomethingJoin.


$FG,5$$TX+CX,"Abreviations"$$FG$

$FG,5$Acct$FG$	Account
$FG,5$Attr$FG$	Attribute
$FG,5$Blk$FG$	Block
$FG,5$Buf$FG$	Buffer
$FG,5$Cb$FG$	Call-back (or code block)
$FG,5$Chnl$FG$	Channel
$FG,5$Cmd$FG$	Command
$FG,5$Cmp$FG$	Compiler
$FG,5$Cnt$FG$	Count
$FG,5$Ctrl$FG$	Control.  The control key is indicated with "$FG,2$^$FG$" in documentation.
$FG,5$Cur$FG$	Current
$FG,5$Dbg$FG$	Debug
$FG,5$Del$FG$	Delete
$FG,5$Dev$FG$	Device
$FG,5$Dir$FG$	Directory
$FG,5$Elem$FG$	Element
$FG,5$Glbl$FG$	Global
$FG,5$Gr$FG$	Graphic
$FG,5$ip_$FG$	Input Pointer.  See $LK,"::/LT/Adam/InputPointer.APZ","FI:::/LT/Adam/InputPointer.APZ"$.
$FG,5$Lex$FG$	Lexical analyser
$FG,5$Lpt$FG$	I think this stands for "line printer port". (It's a DOS term.)
$FG,5$Ltf$FG$	Linked-Text-File (doubly-linked-list of rich text and graphic cmds)
$FG,5$Mem$FG$	Memory
$FG,5$MP$FG$	MultiProcessor
$FG,5$Msg$FG$	Message
$FG,5$Num$FG$	Number
$FG,5$Ode$FG$	Ordinary differential equation
$FG,5$Pmt$FG$	Prompt
$FG,5$Ptr$FG$	Pointer
$FG,5$Rep$FG$	Report
$FG,5$Rmt$FG$	Remote
$FG,5$Rx$FG$	Receive
$FG,5$Str$FG$	String
$FG,5$Sys$FG$	System
$FG,5$Tx$FG$	Transmit
$FG,5$Var$FG$	Variable
$FG,5$Win$FG$	Window
 