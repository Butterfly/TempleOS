$WW,1$* The support for 3 dimensional graphics is not very good.  You'll probably just get frustrated.

* $FG,4$Gs->grbase$FG$ is a bitmap for persistent data on the screen, not needing to be redrawn.  You create an alias for this by using $LK,"GrAlias","MN:GrAlias"$() and work with that.  This image is XORed on top of everything, so the colors you work with, you usually XOR with WHITE to compensate. (White is usually the text background color. XORing twice gets you to what you started with.) It's slightly simpler using this bitmap then $LK,"grbase2","MN:grbase2"$, but it's not as good because changes aren't syncronized to the screen update and window borders are not enforced.  See $LK,"::/LT/Demo/Graphics/DotNet.CPZ","FI:::/LT/Demo/Graphics/DotNet.CPZ"$

* There is actually one $FG,4$Gs->grbase$FG$ for each core and they get merged.  See $LK,"::/LT/Demo/MultiCore2.CPZ","FI:::/LT/Demo/MultiCore2.CPZ"$

* $LK,"grbase2","MN:grbase2"$ is a bitmap for the screen, redrawn each refresh.  You create an alias with $LK,"GrAlias","MN:GrAlias"$() and work with that.  You must change the "$FG,2$Fs->update_win$FG$" variable to point to your update function and must draw everything in the window over and over again. "$FG,2$DrawIt()$FG$" is the preferred name for your update function, so everyone is consistent.  See $LK,"::/LT/Demo/Graphics/Box.CPZ","FI:::/LT/Demo/Graphics/Box.CPZ"$
 
* Use $LK,"GrAlias","MN:GrAlias"$() to create your own structure for accessing the screen and pass it either $FG,4$Gs->grbase$FG$ or $LK,"grbase2","MN:grbase2"$.  (Free it with $LK,"GrDel","MN:GrDel"$() when finished).  A $LK,"GrBitMap","MN:GrBitMap"$ returned by $LK,"GrAlias","MN:GrAlias"$() stores the pen width and current color.  It also can hold info necessary to rotate the whole image in 3D and shift it around.

* Use $LK,"GrBitMapNew","MN:GrBitMapNew"$() to create a memory bitmap which can be used to work off-line and which can be $LK,"GrBlot","MN:GrBlot"$ed onto the screen.  If you set $FG,2$brush$FG$ member of $FG,2$GrBitMap$FG$ to another $FG,2$GrBitMap$FG$, all the graphic routines will $LK,"GrBlot","MN:GrBlot"$() the brush instead of $LK,"GrPlot","MN:GrPlot"$().  See $LK,"::/LT/Demo/Graphics/Blot.CPZ","FI:::/LT/Demo/Graphics/Blot.CPZ"$.

* There are various flavors of line and point plotting routines.  $LK,"GrLine","MN:GrLine"$() and $LK,"GrPlot","MN:GrPlot"$() are the simplest.  The others allow 3 dimensional graphics.

* $LK,"GrTheta","MN:GrTheta"$() and $LK,"GrPhi","MN:GrPhi"$() create matrices for 3 dimensional rotations. You pass them an angle in radians.  To make the matrices take effect, assign them to your graphic $LK,"GrBitMap","MN:GrBitMap"$'s "$FG,2$r$FG$" variable and set the $LK,"BMF_TRANSFORMATION","MN:BMF_TRANSFORMATION"$ flag.  Transformations (rotations) can be combined using $LK,"GrMulMat","MN:GrMulMat"$().  See $LK,"::/LT/Demo/Graphics/Box.CPZ","FI:::/LT/Demo/Graphics/Box.CPZ"$.

* You can rotate single points using $LK,"GrRotate","MN:GrRotate"$().

* You can shift the image around by changing a $LK,"GrBitMap","MN:GrBitMap"$'s "$FG,2$x$FG$","$FG,2$y$FG$" and "$FG,2$z$FG$" variables.

* Use the resource editor, $FG,2$CTRL-R$FG$, to create a picture-like thing called a Graphic Element that can be plotted with $LK,"GrElemsPlot","MN:GrElemsPlot"$().  Use $FG,2$$$IB,"",1$$$FG$ in a source program to insert the address of picture #1.  (After creating a picture with $FG,2$CTRL-R$FG$ in your source code, toggle to plain text with $FG,2$CTRL-T$FG$ and check it's number.  Then, make an assignment to a pointer variable with $FG,2$$$IB,"",n$$$FG$ as the value. See $LK,"::/LT/Demo/Graphics/Sprite1.CPZ","FI:::/LT/Demo/Graphics/Sprite1.CPZ"$ and $LK,"::/LT/Demo/Graphics/Sprite2.CPZ","FI:::/LT/Demo/Graphics/Sprite2.CPZ"$.)  The origin (zero point) for a graphic element is defined by the cursor location when you press $FG,2$CTRL-R$FG$.  The "$FG,2$x$FG$", "$FG,2$y$FG$" and "$FG,2$z$FG$" values you pass to $LK,"GrElemsPlot","MN:GrElemsPlot"$() shift it around.  You can edit a Graphic Element by clicking the cursor on it and pressing $FG,2$CTRL-R$FG$ again.

* There is a mechanism built-in for generating motion based on differential equations, which allows real-world physics.  You create an $LK,"Ode","MN:Ode"$ struct with $LK,"OdeNew","MN:OdeNew"$(), passing it the number of variables in the state vector.  For real-world physics, you usually have 2 state variables for each dimension (for each mass) because motion is governed by f=ma which is a 2nd order equation.  The two states are position and velocity and to solve these you need to supply the derivative of position and velocity.  The derivative of position is usually simply the current velocity and the derivative of velocity is the acceleration (the sum of forces on a mass divided by mass).  To help provide meaningful names for values in the state vector, you can create an $LK,"Order2D3","MN:Order2D3"$ pointer and point it to a mass in the state vector.  Six elements in the state vector are required for each mass.

See $LK,"::/LT/Apps/Rocks/Rocks.CPZ","FI:::/LT/Apps/Rocks/Rocks.CPZ"$



